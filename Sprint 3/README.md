
# Sprint 3 System Design

## Program Organization
* [System Design](https://drive.google.com/file/d/1jLuTz9hMdekggEr7gyuucSSUol9e0XDF/view?usp=sharing)
![alt text](https://raw.githubusercontent.com/jin0s/Crossing-Words/master/Sprint%203/Design%20Documents/SystemDiagram.PNG)
## Major Classes
* [UML](https://drive.google.com/file/d/1p0xWuy4sp1mSsMqn8s_j10ji1tLLKYL1/view?usp=sharing)
![alt text](https://raw.githubusercontent.com/jin0s/Crossing-Words/master/Sprint%203/Design%20Documents/Crossing-Words%20UML.png)

The center of the algorithmic object-based backend for this project is the CrosswordGenerator class. The Class is very large, as the algorithmic core of the project is a large backtracking function that attempts to fill in crossword step-by-step, with each cell of the crossword being assigned a random letter. The remainder of the classes largely exist to aid in the compartmentality and readability of the code within the CrosswordGenerator class. On the data side, the ClueRepository class contains the tools for quickly searching for clues and checking to see if answers are valid. Since clues are impossible to randomly generate, we use a large bank of clues from old crosswords. Answers therefore must exist within this bank. The ClueRepository class handles the cleanup of this crossword bank, and implements a Trie via the Trie and TrieNode classes in order to speedup validation queries. The generation algorithm implemented in CrosswordGenerator can be broken down into two large parts: one for generating the structure of the crossword, and the other for populating that structure with answers. The Board class seeks to aid in the implementation of the structure generation, while the Cell and Answer classes seek to aid with the implementation of the answer generation. The Cell and Answer classes are heavily intertwined; this must be the case so that when the backtracking changes any Cell object, the respective Answer objects are updated as well. The remaining classes are for the most part trivial, the Clue and Crossword class exist only to package data in order to keep printing processes out of the main CrosswordGenerator class.

The User stories 15 and 18 are both handled within the ClueRepository class, as that class does the cleanup of the data to ensure that the clues are valid (15), as well as the random selection of the clues to ensure that the clues vary significantly from puzzle to puzzle(18). The remainder of the backend user stories (16,17,19-24) are all handled by the CrosswordGenerator class itself, with the generate_structure() function satisfying 17 and 19-24, and the generate_answers() function satisfying 16.


# Data Design
We have decided not to use a database. The goal of the project was to create an algorithm that will generate random crosswords. The player will then be able to play the crosswords that we generated by visiting the site.

# Business Rules
They're no limitations this project is open source, and no external sources that will impact the program design.

# User Interface Design
![alt text](https://raw.githubusercontent.com/jin0s/Crossing-Words/master/Sprint%203/Design%20Documents/GUI.png)

# Resource Management
The Raspberry Pi will only be used to serve the webpage and will not need immense processing power or memory. The python crossword generator will run on a separate computer and will not affect the load of the server. Listed below is the servers CPU and Memory that should be taken into consideration when building the webpage:
```
Mem: 927 MB
CPU Name: ARMv7 Processor rev 4 (v7l) 1200 MHz
Number of Processors: 4
```

We did not run into any limiting issues since the server has plenty of memory and processing power.

# Security
We are not storing any user data. Saved crosswords are stored locally on the browser. The website is hosted on a Raspberry Pi on Chinh's Home Network. In order to gain SSH access to the server, the developer's need to provide a public RSA key. OpenSSH password authentication is disabled on the server to prevent bruteforce attacks.
* After gaining access, developer's will be able to SSH using the command 'ssh 72.188.113.6 -l poops -p 8798'
* The server is running the following services:
    ```
    poops@raspberrypi:~/Crossing-Words $ node --version
    v10.15.1
    poops@raspberrypi:~/Crossing-Words $ npm --version
    6.4.1
    ```
* To start the server run:
    ```
    poops@raspberrypi:~/Crossing-Words $ node server.js
    6.4.1
    ```

# Performance

Right now the Python-based back-end that creates the random crosswords is fairly unoptimized, creating a new crossword once every two minutes. In some cases, there are times where the backtracking takes excessive amounts of time to undo mistakes it made in previous decisions; this results from the source of such mistakes being inherently ambiguous. When backtracking, the program therefore sometimes get stuck in a brute-force loop, where no option available can fix the crossword, so every option is exhaustively tried within a small subsection, dramatically increasing runtime. The performance of the program when this doesn’t occur is fairly reasonable; therefore, the generation program attempts to reset backtracking that seems to spiral or loop excessively over a small section.

To ensure the user isn’t waiting two minutes or longer for a crossword to play, the random crosswords are generated at the start of each day and stored for retrieval when a queries the site for one. This ensures that the only loading time is the retrieval of the crossword from the server instead of the generation of the crossword itself.

# Scalability

The Python based back-end could be sped up significantly by finding a better backtracking method of randomly generating a crossword, thus allowing for crosswords to be randomly generated on a much larger scale. As it stands now, with the hardware available to us, only a small set of 50-100 crosswords can be generated a day, which, while undoubtedly providing a single user with enough crosswords for the day, will not ensure that crosswords won’t be shared among users. With faster optimization in the code by finding a more optimal backtrack ordering, this project could be able to ensure that every crossword generated is used only once by one user, ensuring maximum randomness and repeatability.

# Interoperability

The project is composed of two systems, a back-end Python-based backtracking algorithm to construct randomly generated crosswords, and a front-end web-based user interface allowing the user to play the crossword. The crosswords generator will print the crosswords to a file in a format that is easy and efficient for the website to then call up; the crossword prints out text documents that the website interprets as a JSON file containing the specification for the crossword object. The JSON has to be readable, and there are several measures taken by the crossword generator to ensure this is true, such as double quotes being replaced with single quotes as to not break the parser.

The project also interacts with outside systems, mainly web browsers. The site is designed to be simple and engaging, and doesn’t have any parts that would break on any modern browsers with JavaScript enabled.

# Internationalization/Localization

There is not a huge need to localize within this project. Crosswords are not nearly as common in other languages as they are in English, as the major crossword providers are mostly American or UK-based. Therefore localization is largely unecessary. Localization could be added to distinguish between clues of American origin versus clues from the UK; however the difference is small and the effort would be largely unecessary.

# Input/Output

The Input and Output for this project is also relatively simple. The User can interact with the Webpage by entering answers into the crossword and then clicking any of the buttons on the site in order to save/load, receive feedback, or check the answers that they entered into the crossword. The only thing that requires significant interaction other than simple information retrieval is the puzzle validation, which is all done client-side with simple validation checks.

# Error Processing

There aren't any expected errors during runtime; and again, because of the limited interaction the user has with the website beyond simple validation checks on the crossword and small information retrieval calls, there isn't a way for user input to break the system. 

# Fault Tolerance

Again, there is not a lot of capacity for runtime errors on the front-end site, due to the limited interactions with the users. There is more likely to be issues on the back-end side, but the extensive testing methods have found and eliminated any need for any sort of try-catch system. The most likely issue is FileNotFound errors, but these errors are impossible to process as the fundamentally break the system. If no structure files are found by the generator, or no crosswords files are found by the website, then there is nothing to show the user and nothing is displayed.

# Architectural Feasibility

Feasibility really wasn't a concern for the front-end portion of this site, as a web-based application was simple enough to construct and would have little to no issues when considering feasibility. The back-end, however, is a different case. The back-end architecture is entirely based around a backtracking algorithm that attempts to randomly construct a crossword. This algorithm functions by placing a letter in each cell based upon a weighted probability, and in accordance to the fact that both answers the cell is a part of are real answers from a repository of clue/answer pairs. This backtracking method's efficiency is entirely based around the structure of the classes that support it in its efforts, but there is a trade-off here: further support classes could improve the pruning in the backtracking method, increasing the speed at which crosswords generate, but they may also add additional overhead. Additionally, it is incredibly hard to see what additional speed ups further back-end architecture may add to the backtracking without extensive testing.

Overall, a fast enough crossword generator is incredibly feasible, but pushing the limits of the system to guarantee every user a unique, never before seen crossword requires very careful thought and trial-and-error processes. The architecture of the system may not warrant such a level of detail, however.

# Overengineering

The risk of overengineering on the front-end is minimal; there are not a lot of additional unwarranted features that could bloat or unecessarily slow down the system. The back-end is similar; it has a very singular (though complex) purpose; but additional features are not at risk of being added.

The complexity of the back-end system itself is the most at risk of being over-engineered; see the architectural feasibility section for more detailed thoughts on why the complexity of the back-end system is in the state it is in now.

# Build-vs-Buy Decisions

On the back-end we used several very commonly used data and scientific libraries for Python in order to streamline and optimize some simple data processing tasks that we needed to accomplish. Numpy was used in several points to take advantage of its significant speed boosts on many array-based operations, and its random class is far more complete than the default Python random library. Pandas was used to store the set of clues as a dataframe, and provide easy access to several vectorized operations. These two libraries are widely used in Python programming, and are open-source and lightweight to easily be used in many projects without considerable trade-offs. The functions within them are also incredibly fast and highly optimized; creating similar functions within our code would be excessively time-wasting, and would require extensive knowledge on Python and C compatibility.

We also took our clue set from xd.saul.pw, which is a small personal project created by Saul Pwanson. There are many other sources for large sets of crossword clues, but none quite as extensive or as accessible as Saul’s. In the future, as the project scales up, there may be a need to revisit this in order to find other sets of clues, or to update the database with additional cluesets from crosswords made after the site has launched. There is no need to create our own clues, as the clues generated by the crossword makers already present are on a scale much higher than anything replicable by our team.

Our team also used a popular webframe work Node.js to server the webpage. This system is an popular in the industry, usually associated with the MEAN Stack (Mongo.db, Express.js, Angular.js, Node.js).  

# Reuse

With respect with the entire project reusability was not considered. Chances are a crossword generator is a goal specific system that will only generate crosswords. There is possibly reusing some code from the server.js file if we wanted to create new websites. Node.js framework requires specific calls in order to serve the index.js, index.html, and index.css files.


# Change Strategy

Throughout the sprint we consider using some relational database that would sit in between the web files and crossword generator. We wanted to use a database to save progress and return to a crossword that at a later time.

Considering that we do not have any user authentication we decided to used the browser local storage instead to save the states of the crossword. This will reduce bandwidth and load on the server since the user will not need to request anything and load the data from their local machine
